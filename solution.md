Описание проекта:
1. Разделение по слоям:
   1. CRUD: работа с БД.
   CRUD отвечает за работу с базой. Все транзакции только в нем.
   Основная логика в базовом объекте.
   Передача данных:
      1. на вход: словари.
      2. на выход (модели sqlalchemy | выборки):
         * модель из базы (... -> app.src.models.* ) для вставки / изменения / get_by_id;
         * выборки (db.execute(...) -> Result[Any]) для get запросов (кроме get_by_id).
   2. Repository:
   Промежуточный слой м/у CRUD и Service.
   Данные с уровня CRUD переводит в модели pydantic и передает на сервисный слой.
   Осуществляет контроль корректности данных: меню - подменю - блюда.
   Передача данных:
      * CRUD: словари | модели sqlalchemy.
      * Service: модели pydantic.
   3. Service:
   Работает с уровнем Repository. Для каждой сущности свой объект (функционал базового объекта минимальный).
   Дополнительно может собирать ответ с помощью других сервисов
   (например, MenuService.get_full - выгрузка все базы без ORM запроса).
   Передача данных:
      * pydantic модели;
      * "чистый" json для реализации задачи: вывода всех меню со всеми связанными подменю и со всеми связанными блюдами через ORM запрос.

   4. Handlers (routers).
   Собственно ручки. Просто вызывают соответствующий метод сервиса.

    Примечание: при решении несколько нарушен принцип DRY.
    Многие объекты имеют схожий функционал.
    Можно часть кода перенести в базовый класс, правда при этом пострадает читаемость кода.
    И при каком-то существенном изменении функционала мы, скорее всего, будем испытывать сложности с переиспользованием кода.

2. Кеширование:
    Реализовано на уровне "ручек" через использование декораторов @cache и @invalidate_cache (код app.src.routes.utils).
    При реализации декораторов исходил из соглашения, что сущности menu, submenu, dish <i>всегда</i> идентифицируются
    параметрами menu_id, submenu_id, dish_id. Для сторонней утилиты такое допущение вряд ли приемлемо, но для
внутреннего проекта допустимо.
Кеширование и инвалидация кеша происходит в фоне (BackgroundTasks).
3. Фоновые задачи: Celery + Celery beat.

Задачи<sup><b>*</b></sup>:
1. Реализовать вывод количества подменю и блюд для Меню через один (сложный) ORM запрос.
Реализовано: app.src.crud.menus.MenusCRUD.__init__
-----
2. Реализовать тестовый сценарий «Проверка кол-ва блюд и подменю в меню» из Postman с помощью pytest.
Реализовано: app/tests/test_counts.py
-----
3. Описать ручки API в соответствий c OpenAPI.
Реализовано: описание summary, status_code, responses, response_model, response_description в ручках и
полное описание полей в pydantic.
-----
4. Реализовать в тестах аналог Django reverse() для FastAPI.
Использовал встроенный FastApi.url_path_for.
   * app/tests/test_utils_menu.py
   * app/tests/test_utils_submenu.py
   * app/tests/test_utils_dish.py
-----
5. Обновление меню из google sheets раз в 15 сек.
Реализовано: обновление или через локальный файл или через Google sheet. Переключение в .env файле.
Для контроля или разовой синхронизации реализованы ручки /api/v1/file и /api/v1/sheet.
В ответе передается информация об ошибках синхронизации.
Функционал синхронизации в сервисном классе app.src.services.xls_menu.XlsMenuService.
-----
6. Размер скидки (%) указывается в столбце G файла Menu.xlsx.
Не реализовал (((
-----
