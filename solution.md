# Описание проекта:
## Разделение по слоям:
### CRUD.
Отвечает за работу с базой. Все транзакции только в нем.\
Основная логика в базовом объекте.\
Передача данных:
1. на вход: словари.
2. на выход (модели sqlalchemy | выборки):
   * модель из базы (... -> app.src.models.* ) для вставки / изменения / get_by_id;
   * выборки (db.execute(...) -> Result[Any]) для get запросов (кроме get_by_id).
### Repository:
Промежуточный слой между CRUD и Service.\
Данные с уровня CRUD переводит в модели pydantic и передает на сервисный слой.\
Осуществляет контроль корректности данных: меню - подменю - блюда.\
Передача данных:
   * CRUD: словари | модели sqlalchemy.
   * Service: модели pydantic.
### Service:
Работает с уровнем Repository.\
Для каждой сущности свой объект (функционал базового объекта минимальный).
Дополнительно может собирать ответ с помощью других сервисов (например,
MenuService.get_full - выгрузка всей базы без ORM запроса).\
Передача данных:
   * pydantic модели;
   * "чистый" json для реализации задачи: вывода всех меню со всеми связанными подменю и со всеми связанными блюдами через ORM запрос.
### Handlers (routers).
Собственно ручки. Просто вызывают соответствующий метод сервиса.

<i>Примечание: при решении несколько нарушен принцип DRY.\
Многие объекты имеют схожий функционал. Часть кода можно перенести в базовые классы, но
пострадает читаемость кода. И при каком-то существенном изменении требований мы,
скорее всего, будем испытывать сложности с реализацией.\
Например, появились скидки, и мы просто изменили CRUD для dishes (добавили поле в select)
и Service для dishes (пересчет цены при get запросах).</i>

## Кеширование:
Реализовано на уровне "ручек" через использование декораторов @cache и @invalidate_cache (код app.src.routes.utils).\
При реализации декораторов исходил из соглашения, что сущности menu, submenu, dish <i>всегда</i> идентифицируются
параметрами menu_id, submenu_id, dish_id. Для сторонней утилиты такое допущение вряд ли приемлемо, но для
внутреннего проекта допустимо.\
Кеширование и инвалидация кеша происходит в фоне (BackgroundTasks).
Время жизни кеша в .env файле

## Фоновые задачи: Celery + Celery beat.
В зависимости от параметра EXCHANGE_TYPE (SHEET | FILE) выполняется задача синхронизации
с файлом или с Google sheet. Периодичность синхронизации по умолчанию 15 сек.

## Задачи<sup><b>*</b></sup>:

### Реализовать вывод количества подменю и блюд для Меню через один (сложный) ORM запрос.
Реализовано: app.src.crud.menus.MenusCRUD.__init__

-----
### Реализовать тестовый сценарий «Проверка кол-ва блюд и подменю в меню» из Postman с помощью pytest.
Реализовано: app/tests/test_counts.py

-----
### Описать ручки API в соответствий c OpenAPI.
Реализовано: описание summary, status_code, responses, response_model, response_description в ручках и
полное описание полей в pydantic.

-----
### Реализовать в тестах аналог Django reverse() для FastAPI.
Использовал встроенный FastApi.url_path_for.
   * app/tests/test_utils_menu.py
   * app/tests/test_utils_submenu.py
   * app/tests/test_utils_dish.py

-----
### Обновление меню из google sheets раз в 15 сек.
Реализовано.\
Обновление или через локальный файл или через Google sheet.\
Переключение в .env файле.\
Для контроля или разовой синхронизации реализованы ручки /api/v1/file и /api/v1/sheet.\
В ответе передается информация об ошибках синхронизации.\
Функционал синхронизации в сервисном классе app.src.services.xls_menu.XlsMenuService.

-----
### Размер скидки (%) указывается в столбце G файла Menu.xlsx.
Реализовано.\
Все цены блюд возвращаются с учетом скидки. Установка цены - цена без скидки.\
В БД хранится действующая цена и размер скидки (целое число).
В app.src.services.dishes.DishesService.get_by_ids перед возвратом данных в ручки идет
пересчет цены в зависимости от скидки. \
Реализованный ранее ORM запрос (ручка /api/v1/all) возвращает "сырые" данные и там нет
пересчета цены.\
Реализация возврата всех данных через сервисный слой (ручка /api/v1/full) возвращает
пересчитанную цену.

-----
